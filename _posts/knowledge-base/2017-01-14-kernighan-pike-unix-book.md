---
layout: post
title: (Конспект) Brian W. Kernighan, Rob Pike - UNIX. Programming Environment 1984
excerpt: ""
categories: knowledge-base
excerpt: "Конспект с кратким содержанием и интересными моментами для меня книги Brian W. Kernighan, Rob Pike - UNIX. Programming Environment 1984."
excerpt_show: false
tags: [unix, linux, os, fundamentals]
comments: true
share: true
---

![1 article logo]({{ site.url }}/images/what-is-devops-and-buzzwords-part-2/avatar-1.jpg)
{: .center .article-logo}

TODO решить все упражнения

# История {#unix-history}

**Операционная система UNIX 1 стартовала на неиспользовавшейся DEC
PDP 7 в Bell Laboratories в 1969 году. Ken Thompson при помощи и поддержке Rudd Canaday, Doug McIlroy,
Joe Ossanna и Dennis Ritchie написал небольшую универсальную систему с разделением
времени**. Одним из первых пользователей стал Ritchie, 
который помогал перенести систему на PDP 11 в 1970 году.
Кроме того, Ритчи спроектировал и написал компилятор
для языка программирования Си. В 1973 году Ритчи и Томпсон переписали ядро UNIX на Си, прервав таким образом традицию написания
системного программного обеспечения на языке ассемблера. 
И после этой переделки система, по существу, стала тем, чем она и является сегодня.

UNIX – это торговая марка Bell Laboratories. «UNIX» – это не акроним, это
намек на MULTICS, операционную систему, над которой Томпсон и Ритчи
работали до UNIX.

**Почему UNIX имела такой успех?** Можно привести несколько причин:
1. она написана на языке Си, она переносима – UNIX
системы работают на всевозможных компьютерах, от микропроцессоров до мэйнфреймов; это важное коммерческое преимущество.
2. исходный код доступен и написан на языке высокого уровня, что делает простым адаптирование системы для специфических
требований пользователей



# UNIX для начинающих {#unix-for-beginners}

Что такое «UNIX»? В самом узком смысле слова – это ядро операционной системы с разделением времени – программа,
которая управляет ресурсами компьютера и распределяет их между пользователями.

В более широком смысле под «UNIX» понимается не только ядро системы, но и основные программы,
такие как компиляторы, редакторы, командные языки, программы для копирования и печати файлов и т. д.

**Во всех примерах этой книги при няты следующие обозначения: то, что печатает пользователь, 
записывается наклонными буквами, ответы компьютера – обычными символами, а комментарии – курсивом.**

## Man

Справочное руководство по UNIX (man) содержит большинство необходимой информации о системе.

> $ man man

чтобы прочитать о самой команде man.

```
The table below shows the section numbers of the manual followed by the types of pages they contain.

       1   Executable programs or shell commands
       2   System calls (functions provided by the kernel)
       3   Library calls (functions within program libraries)
       4   Special files (usually found in /dev)
       5   File formats and conventions eg /etc/passwd
       6   Games
       7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)
       8   System administration commands (usually only for root)
       9   Kernel routines [Non standard]
```

## Перенаправление ввода-вывода {#input-output}

> $ ls

выводит список файлов на терминал. Если же ввести

> $ ls >filelist

то тот же самый список будет выведен не на терминал, а в файл file list.
Если такой файл не существовал, он будет создан, а если
существовал, то перезаписан. На терминал ничего не выводится. 

Другой пример: можно объединить несколько файлов в один, собрав вывод команды cat в файл:

> $ cat f1 f2 f3 >temp

Названные в аргументах файлы или файл выводятся вместе (отсюда имя cat – catenate – соединять), один за другим, без
каких-либо разделителей.
Catenate – это редко употребляемый синоним слова concatenate (связывать, соединять).

Символ `>>` - «дописывает в конец».

Cимвол `<` показывает, что входные данные программа
должна брать не с терминала, а из файла, указанного далее. 

Например, можно подготовить письмо в файле let.txt, а потом отправить его нескольким адресатам

> $ mail mary joe tom bob <let.txt

Во всех вышеприведенных примерах пробелы с любой стороны от >
или < не обязательны, мы же придерживаемся традиционного форматирования.

Перенаправление вывода с помощью > предоставляет возможность
комбинировать программы, позволяя получать результаты, ранее недоступные.
Например, можно напечатать список пользователей в алфавитном порядке:

```
$ who >temp
$ sort <temp
```

Во всех этих примерах важно помнить, что интерпретацию символов <
и > осуществляет оболочка (как и интерпретацию символов типа * в
шаблонах имен файлов), а не конкретные программы. «Централизция» этой возможности в оболочке означает, 
что перенаправление ввода и вывода может применяться в любых командах;
сама программа и не знает, что происходит что-то необычное.

Из-за этого возникло важное соглашение. Команда

> $ sort <temp

сортирует содержимое файла temp, как и команда

> $ sort temp

но существует отличие. Строка `<temp` интерпретируется оболочкой, по-этому sort не рассматривает имя temp как аргумент,
вместо этого она сортирует свой стандартный ввод, который оболочка перенаправила
таким образом, чтобы он поступал из файла. Во втором же примере с
командой sort имя файла temp передается команде как аргумент, sort
читает файл и сортирует его.

**Поэтому тут зависит от реализации самой программы (sort в гашем случае)**

Это важное свойство большей части команд: **если имена файлов не
указаны, то обрабатывается стандартный ввод.**


```
Упражнение 1.5. Объясните, почему
$ ls >ls.out
включает ls.out в список имен.

$ cat ls.out 
ls.out

```

## Pipes

Во всех примерах предыдущего раздела применялся один и тот же
прием: помещение вывода одной программы на вход другой через временный файл.
Но ведь у временного файла нет другого назначения; на самом деле это слишком грубый метод.

Данное наблюдение привело к созданию концепции программного канала (pipe), одного из наиболее
важных достижений системы UNIX. Канал – это способ подключения вывода одной программы на вход другой
без каких бы то ни было временных файлов; а конвейер (pipeline) – это соединение двух или более
программ посредством каналов.

> $ ls | wc -l # считает количество файлов

Именно в этой ситуации **соглашение
о том, что если программе не указаны имена файлов, то она читает
стандартный ввод, окупается в полной мере: все программы, соблюдающие это соглашение, могут быть включены в конвейеры.**

> $ who | grep mary | wc -l
> подсчитывает, сколько раз Мэри зарегистрирована в системе.

**В действительности все программы конвейера выполняются одновременно, а не одна за другой.**

Это означает, что программа конвейера может быть и интерактивной; ядро следит за тем, как правильно обеспечить
синхронизацию и диспетчеризацию, чтобы все работало. Как вы, наверное, уже догадываетесь, созданием каналов занимается
оболочка; отдельные программы не имеют понятия о перенаправлении ввода-вывода.
Конечно, для того чтобы иметь возможность совместной
работы, программы должны придерживаться определенных соглашений. 
Большинство команд имеет одинаковый дизайн, так что они подходят для любой позиции в конвейере.

У каждой команды есть еще и стандартный вывод ошибок, который обычно направляется на терминал.

```
Упражнение 1.7. Объясните, в чем состоит отличие между
$ who | sort
и
$ who >sort
```

## Processes
 
Оболочка осуществляет немало других операций помимо организации
конвейеров. Давайте ненадолго обратимся к основам одновременного
выполнения нескольких программ, о котором упоминалось в предыдущем разделе. 
Например, можно запустить две программы в одной командной строке, разделив их точкой с запятой; оболочка распознает
точку с запятой и разбивает строку на две команды:
 
```
[root@linux01z1 test] date; who
Sat Jan 14 16:19:13 CET 2017
vagrant  pts/0        2017-01-14 16:16 (gateway)
```

Прежде чем оболочка выдала новое приглашение на ввод, **выполнились обе команды (последовательно)**.

Несколько программ могут выполняться и одновременно:

```
$ ls | wc -l &
[1] 21842
```

Знак амперсанда & в конце командной строки сообщает оболочке, что
следует «начать выполнение этой программы, а затем принимать новые команды с терминала незамедлительно»,
то есть не ждать завершения работы программы.

**Экземпляр выполняющейся программы называется процессом.**

Число, выводимое оболочкой для команды, запущенной со знаком &, называется идентификатором процесса;
с его помощью можно в других командах ссылаться на конкретную выполняющуюся программу.

Знак & относится ко всему конвейеру (во время выполнения конвейера создается несколько процессов).
Но идентификатор выводится только один – для последнего процесса из последовательности.

> $ wait

ждет, пока не выполнятся все процессы, инициированные с использованием &.
Так что если она не возвращается тотчас же, значит ваши программы все еще работают.

Ваш экземпляр оболочки был создан процессом, связанным с терминалом, с которого был
осуществлен вход в систему. Когда вы запускаете команды, эти процессы становятся прямыми потомками оболочки.

Иногда процессу требуется так много времени на выполнение, что возникает желание запустить его,
потом выключить терминал и уйти, не дожидаясь завершения. Однако если выключить терминал или прервать соединение,
то процесс, как правило, будет убит, даже если указать знак &.

**Специально для таких ситуаций создали команду nohup (no hangup – не реагировать на разрыв линии).**

> $ nohup команда &

выполнение команды будет продолжено даже после выхода из системы. Весь вывод команды сохраняется в файле nohup.out.
Способа осуществить nohup команды задним числом не существует.


## Configure environment

Некоторые свойства оболочки определяются так называемыми переменными окружения,
значения которых доступны пользователю и могут быть им изменены. Например, строка приглашения к вводу, выводимая как $,
на самом деле хранится в переменной оболочки PS1, для которой можно установить любое значение, например:

> PS1='Yes dear? '

Кавычки необходимы, так как в строке приглашения есть пробелы. А
вот пробелы вокруг знака = в этой конструкции не разрешены.

Вероятно, самой используемой переменной окружения является та переменная, которая определяет, где оболочка ищет команды.
Вспомните, что при поиске введенной команды оболочка сначала просматривает текущий каталог,
потом каталог /bin и затем /usr/bin. Эта последовательность каталогов называется путем поиска 
и хранится в переменной окружения PATH. Если вас не устраивает значение пути поиска
по умолчанию, можно изменить его в файле ~/.profile (~/.bash_profile ).

Чтобы переменные были видны в других программах - используйте `export`.



# File system

**Все, что ни есть в системе UNIX, – это файл.**

## Basics

Файл – это последовательность байтов. (Байт – 8 бит. В этой книге под байтом мы будем понимать эквивалент символа.) 
Система не навязывает файлу какую-то определенную структуру и никоим образом не пытается трактовать его
содержание, смысл байтов зависит только от программ, которые интерпретируют файл. Кроме того, будет показано, 
что это утверждение верно не только для дисковых файлов, но и для файлов периферийных
устройств. Магнитные ленты, почтовые сообщения, символы, вводимые с клавиатуры, вывод принтера, 
поток данных в программном канале – каждый из этих файлов представляет собой просто последовательность байтов
по отношению к системе и ее программам.

```
echo 1 > 1.txt
ls -l 1.txt 
# -rw-r--r-- 1 root root 2 Jan 14 18:17 1.txt  # 2 байта файл
# посмотрим его содержимое
od -c 1.txt 
# 0000000   1  \n
# 0000002
```

`-c` означает «интерпретировать байты как символы».
Команда cat показывает, как выглядит файл. Команда od (octal dump –
восьмеричный дамп) выводит видимое представление всех байтов файла.

Обратите внимание, что после каждой строки встречается символ с
восьмеричным значением 012. Это ASCII-символ новой строки, то есть
то, что система помещает в поток ввода, когда пользователь нажимает
клавишу Return. По соглашению, заимствованному из Си, представление
символа новой строки выглядит как \n, но это просто условность,
используемая такими программами, как od, для удобства чтения, на
самом же деле величина, хранимая в файле, – это один байт 012.

Изучая вывод команды od, вы не найдете символа конца файла, он
просто заканчивается. Вместо использования специального кода система подписывает конец файла, 
просто сообщая, что данных больше нет. Ядро хранит сведения о длинах файлов, 
поэтому программа обнаруживает конец файла, когда обработает его последний байт.

**Программа получает данные файла, используя системный вызов (подпрограмму ядра) read**.
При каждом вызове read возвращает очередную
порцию данных – следующую строку текста, вводимого с терминала, к
примеру. Кроме того, она сообщает, сколько байтов файла было получено,
так что, **получив от read сообщение «получено ноль байтов»,
можно считать, что достигнут конец файла**. Если же какие-либо байты
еще остались, read вернет часть из них.

Когда программа читает данные с терминала, ядро передает ей каждую вводимую строку только
после ввода символа новой строки (т. е. при нажатии Return). Поэтому, пока символ новой строки не введен,
есть возможность вернуться и исправить замеченную опечатку.


## File

Команда file делает предположение о типе файла

```
file /bin/ /bin/ls /lib64/libanl-2.17.so 
# /bin/:                 directory
# /bin/ls:               ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped
# /lib64/libanl-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), BuildID[sha1]=f045e545ce6d86af8ed3c2943d1c1b5d051669cd, for GNU/Linux 2.6.32, not stripped
```

Для определения типа файла команда file не использует его имя,
так как соглашения об именовании – это всего лишь соглашения. Например, файлы с
расширением .c почти всегда содержат исходные тексты на Си, но ничто не мешает создать такой файл с произвольным содержимым.
Вместо этого file читает первые несколько сотен байт и ищет в них
ключевые последовательности символов. (Как будет показано ниже,
специальные системные файлы, такие как каталоги, могут быть определены путем запроса к системе,
но команда file может идентифицировать каталог при его чтении.)
Иногда ключи очевидны. Исполняемая программа начинается с «магического числа» в двоичном представлении.

В текстовых файлах ключи могут встречаться среди прочего текста,
поэтому file определяет исходные тексты на Си по наличию таких
слов, как #include, а входные данные программ nroff или troff – по наличию точки в начале строки.


## Dir and File names

Команда pwd (print working directory – печатать текущий каталог) выводит имя текущего каталога.

Текущий каталог является атрибутом процесса, а не пользователя или
программы – у пользователей есть регистрационные каталоги, а у процессов – текущие. 
Если процесс порождает другой процесс, то потомок наследует текущий каталог своего родителя. Но если дочерний процесс
переходит в другой каталог, на родителе это никак не отражается – его
текущий каталог останется прежним, что бы ни делали его потомки.

Понятие текущего каталога введено во многом для удобства обозначения, 
ведь оно позволяет значительно сократить объем вводимого текста, но его основное назначение – организационное.

Если вы перешли в конкретную директорию, то имя файла напечатается без префикса:

> $ ls
> junk

Каталоги, несмотря на свои особые свойства с точки зрения ядра, 
располагаются в файловой системе, как обычные файлы. Они могут быть
прочитаны, как и все файлы. Но в отличие от остальных, файлы каталогов 
не могут быть созданы или изменены обычными средствами; для
сохранения целостности файловой системы ядро оставляет за собой
контроль над содержимым этих файлов.

```
Упражнение 2.3.
Как работает команда pwd?
```


## Access rights

Каждый файл имеет связанный с ним набор прав, определяющих, кто
и что может делать с этим файлом.

super-user может читать и модифицировать любые файлы в системе. Права суперпользователя присвоены регистрационному имени root.
Существует команда su, предоставляющая статус суперпользователя каждому, кто знает пароль. **Любой
обладатель такого пароля получит доступ к вашим любовным письмам,
поэтому не стоит хранить в системе столь секретные материалы :)**

Если быть более точным, то права суперпользователя будут делегированы
системой любому процессу пользователя, эффективный пользовательский
**идентификатор которого равен нулю** (идентификатор `root` можно сменить на любой другой, главное, что uid == 0).

Для сохранения конфиденциальности можно применять команду `crypt`, которая шифрует данные.

```
ls -l /bin/passwd 
-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /bin/passwd
```

Символ `s` (атрибута SUID (set-uid)) вместо x в поле прав на исполнение для владельца
говорит о том, что команда во время выполнения приобретает права
своего владельца, в данном случае root.

Нужно быть аккуратным с `s`, так как при `-rwsrwxrwx`, (`w` для всех) то любой пользователь может
заменить ее собственной программой. Это особенно критично для программ, имеющих атрибут SUID,
так как пользователь root имеет права
на доступ ко всем файлам системы.

Независимо от
имеющихся разрешений, только владелец файла и super-user может изменить права доступа к нему.
Даже если кто-либо предоставит пользователю права на запись в файл, система не позволит ему изменить биты прав доступа

### File access rights

Здесь всё просто

- `r` доступ на чтение
- `w` доступ на запись
- `x` доступ на исполнение

### Directory access rights

Команда ls с параметром -d выводит **сведения о самом каталоге**, а не о
его содержимом, а d в начале строки подтверждает, что «.» действительно является каталогом.

- `r` означает, что каталог доступен для
чтения, и его содержимое может быть просмотрено с помощью команды ls (или, при желании, od). 
- `w` возможно создание и удаление файлов в этом каталоге, поскольку эти действия
требуют записи в файл каталога.

**На самом деле вы не можете записывать данные прямо в файл каталога – это запрещено даже суперпользователю.**

Для этой цели применяются системные вызовы, позволяющие создавать и удалять файлы, – только с их помощью можно
вносить изменения в файл каталога. Но механизм прав доступа работает и здесь: поле
w определяет, кто может использовать системные программы для изменения каталога.

**Разрешение на удаление файла не связано с самим файлом. При наличии права на запись в каталог
можно удалить файлы даже в том случае, если они защищены от записи.**

- `x` разрешает не исполнение, а поиск (переход по иерархии).
Таким образом, можно создать каталог с правами `--x` для остальных пользователей, что позволит им 
получить доступ к тем файлам, которые им известны, но не даст выполнить
команду ls для просмотра всего содержимого каталога.

Аналогично, в каталоге с правами доступа `r--` пользователи могут просматривать его
содержимое, но не могут с ним работать.

В некоторых конфигурациях это свойство используется для отключения каталога /usr/games в рабочее время :)

Обратите внимание на то, что изменение прав доступа к каталогу не затрагивает дату его модификации. 
Дата модификации отражает изменения в содержании каталога, а не в его свойствах. 
Права доступа и даты хранятся не в самом файле, а в индексном дескрипторе (inode)

## inode

Файл имеет несколько компонентов: имя, содержимое, служебную информацию, такую как права доступа и время модификации.
Служебная информация хранится в индексном дескрипторе («inode»).

Индексный дескриптор хранит три значения времени: 
1. время последнего изменения (записи) `ls -l <file>`
2. время последнего использования (чтения или выполнения) `ls -lu <file>`
3. время последнего изменения самого индексного дескриптора, например при изменении прав доступа `ls -lc <file>`

```
touch file_1.txt 
ls -l file_1.txt  # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
ls -lu file_1.txt # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
ls -lc file_1.txt # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
```

допишем что-нибудь в файл:

```
echo 123 > file_1.txt 

ls -l file_1.txt  # Jan 15 15:21 <CHANGED>
ls -lu file_1.txt # Jan 15 15:19
ls -lc file_1.txt # Jan 15 15:21 <CHANGED>
```

изменим permissions файла:

```
chmod +x > file_1.txt 

ls -l file_1.txt  # Jan 15 15:21
ls -lu file_1.txt # Jan 15 15:19
ls -lc file_1.txt # Jan 15 17:37 <CHANGED>
```

прочитаем файл:

```
cat file_1.txt 

ls -l file_1.txt  # Jan 15 15:21
ls -lu file_1.txt # Jan 15 17:40 <CHANGED>
ls -lc file_1.txt # Jan 15 17:37
```

Команда `ls -t` сортирует файлы по времени, по умолчанию это время
последнего изменения. Параметр `-t` может применяться совместно с
параметром `-c` или `-u` для определения порядка изменения индексных
дескрипторов или чтения файлов.

Понимание индексных дескрипторов необходимо не только с точки
зрения параметров команды ls, но и потому, что можно сказать, что
inode – это есть файлы.

id inode (i-number) можно получить через `ls -i`

Перед именем файла, в первых двух байтах записи каталога, как раз и
хранится номер inode-ы.
Первые два байта каждой записи каталога являются единственной
связью имени файла с его содержимым. Поэтому имя файла и называется ссылкой, ведь оно связывает 
имя в иерархии каталогов с индексным дескриптором и, следовательно, с данными.

Одно и то же значение номера индексного дескриптора может встречаться в нескольких
каталогах. **Команда rm в действительности удаляет не индексные дескрипторы, а записи в каталоге, то есть ссылки.**
И только когда исчезнет последняя ссылка на файл, система удаляет индексный дескриптор, а значит и сам файл.

Ссылки, указывающие на один файл, имеют одинаковые значения номера индексного дескриптора:

```
ln junk linktojunk
ls 

15768 -rw-rw-rw- 2 you 29 Sep 27 12:07 junk
15768 -rw-rw-rw- 2 you 29 Sep 27 12:07 linktojunk
```

Число между строкой прав доступа и именем владельца показывает
количество ссылок на файл.

Поскольку ссылка есть лишь указатель на
запись в индексном дескрипторе, все ссылки равноправны, нет разницы между первой 
из них и всеми последующими. **(Имейте в виду, что из-за таких повторов ls неправильно подсчитывает итоговый объем
дискового пространства.)**

```
Упражнение 2.6. Почему команда ls -l сообщает о 4 ссылках на recipes? Подсказка: используйте
$ ls 
ld /usr/you
Чем полезна эта информация?
```

```
Упражнение 2.7. В чем разница между
$ mv junk junk1
и
$ cp junk junk1
$ rm junk

Ответ: mv сохраняет inode id
```


## Устройства TODO translate it

`/dev` содержит файлы устройств.

```
ls -l /dev
total 0
crw------- 1 root    root     10, 235 Jan 14 13:02 autofs
drwxr-xr-x 2 root    root          80 Jan 14 13:02 block
drwxr-xr-x 2 root    root          60 Jan 14 13:02 bsg
```

В индексном дескрипторе файла устройства содержится внутреннее имя устройства,
состоящее из обозначения типа символа `c` для символьного или `b` для
блочного, и пара чисел, называемых старшим и младшим номерами
устройства. Диски и ленты являются блочными устройствами, а все остальные – терминалы, принтеры, телефонные линии и 
т. д. – символьными. Старший номер определяет тип устройства, а младший обозначает конкретный экземпляр устройства.

```
crw--w---- 1 root tty     4,  0 Jan 14 13:02 /dev/tty0
crw--w---- 1 root tty     4,  1 Jan 14 13:02 /dev/tty1
crw--w---- 1 root tty     4, 10 Jan 14 13:02 /dev/tty10
```

например здесь мы видим, что для всех терминалов младший номер одинаковый и равен 4.

В процессе начальной загрузки
проверяется целостность всех файловых систем (см. icheck(8) или
fsck(8)), после чего они присоединяются к корневой системе. Операция присоединения 
называется монтированием и представляет собой
программный аналог установки нового диска в дисковод, для ее выполнения необходимы привилегии суперпользователя.

Обычно пользователю нет необходимости задумываться о том, куда
смонтирована каждая из файловых систем, ходя здесь есть два существенных момента. Во-первых,
запрещено создание ссылок на файлы, расположенные в других файловых подсистемах, 
так как они монтируются и размонтируются независимо друг от друга.

Еще одно препятствие состоит в том, что различные файловые системы 
могут содержать совпадающие номера индексных дескрипторов.

Вывод команды можно исключить, перенаправив его в устройство `/dev/null`

Данные, выводимые в /dev/null, пропадают без каких-либо комментариев, 
а при попытке ввода из /dev/null программа немедленно получает признак конца файла, так как операция чтения возвращает ноль
байт.




# Shell

