---
layout: post
title: (Конспект) Brian W. Kernighan, Rob Pike - UNIX. Programming Environment 1984
excerpt: ""
categories: knowledge-base
excerpt: "Конспект с кратким содержанием и интересными моментами для меня книги Brian W. Kernighan, Rob Pike - UNIX. Programming Environment 1984."
excerpt_show: false
tags: [unix, linux, os, fundamentals]
comments: true
share: true
---

![1 article logo]({{ site.url }}/images/what-is-devops-and-buzzwords-part-2/avatar-1.jpg)
{: .center .article-logo}

TODO решить все упражнения
TODO ссылка на магазины где можно купить книгу

# История {#unix-history}

**Операционная система UNIX 1 стартовала на неиспользовавшейся DEC
PDP 7 в Bell Laboratories в 1969 году. Ken Thompson при помощи и поддержке Rudd Canaday, Doug McIlroy,
Joe Ossanna и Dennis Ritchie написал небольшую универсальную систему с разделением
времени**. Одним из первых пользователей стал Ritchie, 
который помогал перенести систему на PDP 11 в 1970 году.
Кроме того, Ритчи спроектировал и написал компилятор
для языка программирования Си. В 1973 году Ритчи и Томпсон переписали ядро UNIX на Си, прервав таким образом традицию написания
системного программного обеспечения на языке ассемблера. 
И после этой переделки система, по существу, стала тем, чем она и является сегодня.

UNIX - это торговая марка Bell Laboratories. «UNIX» - это не акроним, это
намек на MULTICS, операционную систему, над которой Томпсон и Ритчи
работали до UNIX.

**Почему UNIX имела такой успех?** Можно привести несколько причин:
1. она написана на языке Си, она переносима - UNIX
системы работают на всевозможных компьютерах, от микропроцессоров до мэйнфреймов; это важное коммерческое преимущество.
2. исходный код доступен и написан на языке высокого уровня, что делает простым адаптирование системы для специфических
требований пользователей



# Chapter 1 - UNIX for beginners

Что такое «UNIX»? В самом узком смысле слова - это ядро операционной системы с разделением времени - программа,
которая управляет ресурсами компьютера и распределяет их между пользователями.

В более широком смысле под «UNIX» понимается не только ядро системы, но и основные программы,
такие как компиляторы, редакторы, командные языки, программы для копирования и печати файлов и т. д.

**Во всех примерах этой книги при няты следующие обозначения: то, что печатает пользователь, 
записывается наклонными буквами, ответы компьютера - обычными символами, а комментарии - курсивом.**

## Man

Справочное руководство по UNIX (man) содержит большинство необходимой информации о системе.

> $ man man

чтобы прочитать о самой команде man.

```
The table below shows the section numbers of the manual followed by the types of pages they contain.

       1   Executable programs or shell commands
       2   System calls (functions provided by the kernel)
       3   Library calls (functions within program libraries)
       4   Special files (usually found in /dev)
       5   File formats and conventions eg /etc/passwd
       6   Games
       7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)
       8   System administration commands (usually only for root)
       9   Kernel routines [Non standard]
```

## Перенаправление ввода-вывода {#input-output}

> $ ls

выводит список файлов на терминал. Если же ввести

> $ ls >filelist

то тот же самый список будет выведен не на терминал, а в файл file list.
Если такой файл не существовал, он будет создан, а если
существовал, то перезаписан. На терминал ничего не выводится. 

Другой пример: можно объединить несколько файлов в один, собрав вывод команды cat в файл:

> $ cat f1 f2 f3 >temp

Названные в аргументах файлы или файл выводятся вместе (отсюда имя cat - catenate - соединять), один за другим, без
каких-либо разделителей.
Catenate - это редко употребляемый синоним слова concatenate (связывать, соединять).

Символ `>>` - «дописывает в конец».

Cимвол `<` показывает, что входные данные программа
должна брать не с терминала, а из файла, указанного далее. 

Например, можно подготовить письмо в файле let.txt, а потом отправить его нескольким адресатам

> $ mail mary joe tom bob <let.txt

Во всех вышеприведенных примерах пробелы с любой стороны от >
или < не обязательны, мы же придерживаемся традиционного форматирования.

Перенаправление вывода с помощью > предоставляет возможность
комбинировать программы, позволяя получать результаты, ранее недоступные.
Например, можно напечатать список пользователей в алфавитном порядке:

```
$ who >temp
$ sort <temp
```

Во всех этих примерах важно помнить, что интерпретацию символов <
и > осуществляет оболочка (как и интерпретацию символов типа * в
шаблонах имен файлов), а не конкретные программы. «Централизция» этой возможности в оболочке означает, 
что перенаправление ввода и вывода может применяться в любых командах;
сама программа и не знает, что происходит что-то необычное.

Из-за этого возникло важное соглашение. Команда

> $ sort <temp

сортирует содержимое файла temp, как и команда

> $ sort temp

но существует отличие. Строка `<temp` интерпретируется оболочкой, по-этому sort не рассматривает имя temp как аргумент,
вместо этого она сортирует свой стандартный ввод, который оболочка перенаправила
таким образом, чтобы он поступал из файла. Во втором же примере с
командой sort имя файла temp передается команде как аргумент, sort
читает файл и сортирует его.

**Поэтому тут зависит от реализации самой программы (sort в гашем случае)**

Это важное свойство большей части команд: **если имена файлов не
указаны, то обрабатывается стандартный ввод.**


```
Упражнение 1.5. Объясните, почему
$ ls >ls.out
включает ls.out в список имен.

$ cat ls.out 
ls.out

```

## Pipes

Во всех примерах предыдущего раздела применялся один и тот же
прием: помещение вывода одной программы на вход другой через временный файл.
Но ведь у временного файла нет другого назначения; на самом деле это слишком грубый метод.

Данное наблюдение привело к созданию концепции программного канала (pipe), одного из наиболее
важных достижений системы UNIX. Канал - это способ подключения вывода одной программы на вход другой
без каких бы то ни было временных файлов; а конвейер (pipeline) - это соединение двух или более
программ посредством каналов.

> $ ls | wc -l # считает количество файлов

Именно в этой ситуации **соглашение
о том, что если программе не указаны имена файлов, то она читает
стандартный ввод, окупается в полной мере: все программы, соблюдающие это соглашение, могут быть включены в конвейеры.**

> $ who | grep mary | wc -l
> подсчитывает, сколько раз Мэри зарегистрирована в системе.

**В действительности все программы конвейера выполняются одновременно, а не одна за другой.**

Это означает, что программа конвейера может быть и интерактивной; ядро следит за тем, как правильно обеспечить
синхронизацию и диспетчеризацию, чтобы все работало. Как вы, наверное, уже догадываетесь, созданием каналов занимается
оболочка; отдельные программы не имеют понятия о перенаправлении ввода-вывода.
Конечно, для того чтобы иметь возможность совместной
работы, программы должны придерживаться определенных соглашений. 
Большинство команд имеет одинаковый дизайн, так что они подходят для любой позиции в конвейере.

У каждой команды есть еще и стандартный вывод ошибок, который обычно направляется на терминал.

```
Упражнение 1.7. Объясните, в чем состоит отличие между
$ who | sort
и
$ who >sort
```

## Processes
 
Оболочка осуществляет немало других операций помимо организации
конвейеров. Давайте ненадолго обратимся к основам одновременного
выполнения нескольких программ, о котором упоминалось в предыдущем разделе. 
Например, можно запустить две программы в одной командной строке, разделив их точкой с запятой; оболочка распознает
точку с запятой и разбивает строку на две команды:
 
```
[root@linux01z1 test] date; who
Sat Jan 14 16:19:13 CET 2017
vagrant  pts/0        2017-01-14 16:16 (gateway)
```

Прежде чем оболочка выдала новое приглашение на ввод, **выполнились обе команды (последовательно)**.

Несколько программ могут выполняться и одновременно:

```
$ ls | wc -l &
[1] 21842
```

Знак амперсанда & в конце командной строки сообщает оболочке, что
следует «начать выполнение этой программы, а затем принимать новые команды с терминала незамедлительно»,
то есть не ждать завершения работы программы.

**Экземпляр выполняющейся программы называется процессом.**

Число, выводимое оболочкой для команды, запущенной со знаком &, называется идентификатором процесса;
с его помощью можно в других командах ссылаться на конкретную выполняющуюся программу.

Знак & относится ко всему конвейеру (во время выполнения конвейера создается несколько процессов).
Но идентификатор выводится только один - для последнего процесса из последовательности.

> $ wait

ждет, пока не выполнятся все процессы, инициированные с использованием &.
Так что если она не возвращается тотчас же, значит ваши программы все еще работают.

Ваш экземпляр оболочки был создан процессом, связанным с терминалом, с которого был
осуществлен вход в систему. Когда вы запускаете команды, эти процессы становятся прямыми потомками оболочки.

Иногда процессу требуется так много времени на выполнение, что возникает желание запустить его,
потом выключить терминал и уйти, не дожидаясь завершения. Однако если выключить терминал или прервать соединение,
то процесс, как правило, будет убит, даже если указать знак &.

**Специально для таких ситуаций создали команду nohup (no hangup - не реагировать на разрыв линии).**

> $ nohup команда &

выполнение команды будет продолжено даже после выхода из системы. Весь вывод команды сохраняется в файле nohup.out.
Способа осуществить nohup команды задним числом не существует.


## Configure environment

Некоторые свойства оболочки определяются так называемыми переменными окружения,
значения которых доступны пользователю и могут быть им изменены. Например, строка приглашения к вводу, выводимая как $,
на самом деле хранится в переменной оболочки PS1, для которой можно установить любое значение, например:

> PS1='Yes dear? '

Кавычки необходимы, так как в строке приглашения есть пробелы. А
вот пробелы вокруг знака = в этой конструкции не разрешены.

Вероятно, самой используемой переменной окружения является та переменная, которая определяет, где оболочка ищет команды.
Вспомните, что при поиске введенной команды оболочка сначала просматривает текущий каталог,
потом каталог /bin и затем /usr/bin. Эта последовательность каталогов называется путем поиска 
и хранится в переменной окружения PATH. Если вас не устраивает значение пути поиска
по умолчанию, можно изменить его в файле ~/.profile (~/.bash_profile ).

Чтобы переменные были видны в других программах - используйте `export`.



# Chapter 2 - File system

**Все, что ни есть в системе UNIX, - это файл.**

## Basics

Файл - это последовательность байтов. (Байт - 8 бит. В этой книге под байтом мы будем понимать эквивалент символа.) 
Система не навязывает файлу какую-то определенную структуру и никоим образом не пытается трактовать его
содержание, смысл байтов зависит только от программ, которые интерпретируют файл. Кроме того, будет показано, 
что это утверждение верно не только для дисковых файлов, но и для файлов периферийных
устройств. Магнитные ленты, почтовые сообщения, символы, вводимые с клавиатуры, вывод принтера, 
поток данных в программном канале - каждый из этих файлов представляет собой просто последовательность байтов
по отношению к системе и ее программам.

```
echo 1 > 1.txt
ls -l 1.txt 
# -rw-r--r-- 1 root root 2 Jan 14 18:17 1.txt  # 2 байта файл
# посмотрим его содержимое
od -c 1.txt 
# 0000000   1  \n
# 0000002
```

`-c` означает «интерпретировать байты как символы».
Команда cat показывает, как выглядит файл. Команда od (octal dump -
восьмеричный дамп) выводит видимое представление всех байтов файла.

Обратите внимание, что после каждой строки встречается символ с
восьмеричным значением 012. Это ASCII-символ новой строки, то есть
то, что система помещает в поток ввода, когда пользователь нажимает
клавишу Return. По соглашению, заимствованному из Си, представление
символа новой строки выглядит как \n, но это просто условность,
используемая такими программами, как od, для удобства чтения, на
самом же деле величина, хранимая в файле, - это один байт 012.

Изучая вывод команды od, вы не найдете символа конца файла, он
просто заканчивается. Вместо использования специального кода система подписывает конец файла, 
просто сообщая, что данных больше нет. Ядро хранит сведения о длинах файлов, 
поэтому программа обнаруживает конец файла, когда обработает его последний байт.

**Программа получает данные файла, используя системный вызов (подпрограмму ядра) read**.
При каждом вызове read возвращает очередную
порцию данных - следующую строку текста, вводимого с терминала, к
примеру. Кроме того, она сообщает, сколько байтов файла было получено,
так что, **получив от read сообщение «получено ноль байтов»,
можно считать, что достигнут конец файла**. Если же какие-либо байты
еще остались, read вернет часть из них.

Когда программа читает данные с терминала, ядро передает ей каждую вводимую строку только
после ввода символа новой строки (т. е. при нажатии Return). Поэтому, пока символ новой строки не введен,
есть возможность вернуться и исправить замеченную опечатку.


## File

Команда file делает предположение о типе файла

```
file /bin/ /bin/ls /lib64/libanl-2.17.so 
# /bin/:                 directory
# /bin/ls:               ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped
# /lib64/libanl-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), BuildID[sha1]=f045e545ce6d86af8ed3c2943d1c1b5d051669cd, for GNU/Linux 2.6.32, not stripped
```

Для определения типа файла команда file не использует его имя,
так как соглашения об именовании - это всего лишь соглашения. Например, файлы с
расширением .c почти всегда содержат исходные тексты на Си, но ничто не мешает создать такой файл с произвольным содержимым.
Вместо этого file читает первые несколько сотен байт и ищет в них
ключевые последовательности символов. (Как будет показано ниже,
специальные системные файлы, такие как каталоги, могут быть определены путем запроса к системе,
но команда file может идентифицировать каталог при его чтении.)
Иногда ключи очевидны. Исполняемая программа начинается с «магического числа» в двоичном представлении.

В текстовых файлах ключи могут встречаться среди прочего текста,
поэтому file определяет исходные тексты на Си по наличию таких
слов, как #include, а входные данные программ nroff или troff - по наличию точки в начале строки.


## Dir and File names

Команда pwd (print working directory - печатать текущий каталог) выводит имя текущего каталога.

Текущий каталог является атрибутом процесса, а не пользователя или
программы - у пользователей есть регистрационные каталоги, а у процессов - текущие. 
Если процесс порождает другой процесс, то потомок наследует текущий каталог своего родителя. Но если дочерний процесс
переходит в другой каталог, на родителе это никак не отражается - его
текущий каталог останется прежним, что бы ни делали его потомки.

Понятие текущего каталога введено во многом для удобства обозначения, 
ведь оно позволяет значительно сократить объем вводимого текста, но его основное назначение - организационное.

Если вы перешли в конкретную директорию, то имя файла напечатается без префикса:

> $ ls
> junk

Каталоги, несмотря на свои особые свойства с точки зрения ядра, 
располагаются в файловой системе, как обычные файлы. Они могут быть
прочитаны, как и все файлы. Но в отличие от остальных, файлы каталогов 
не могут быть созданы или изменены обычными средствами; для
сохранения целостности файловой системы ядро оставляет за собой
контроль над содержимым этих файлов.

```
Упражнение 2.3.
Как работает команда pwd?
```


## Access rights

Каждый файл имеет связанный с ним набор прав, определяющих, кто
и что может делать с этим файлом.

super-user может читать и модифицировать любые файлы в системе. Права суперпользователя присвоены регистрационному имени root.
Существует команда su, предоставляющая статус суперпользователя каждому, кто знает пароль. **Любой
обладатель такого пароля получит доступ к вашим любовным письмам,
поэтому не стоит хранить в системе столь секретные материалы :)**

Если быть более точным, то права суперпользователя будут делегированы
системой любому процессу пользователя, эффективный пользовательский
**идентификатор которого равен нулю** (идентификатор `root` можно сменить на любой другой, главное, что uid == 0).

Для сохранения конфиденциальности можно применять команду `crypt`, которая шифрует данные.

```
ls -l /bin/passwd 
-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /bin/passwd
```

Символ `s` (атрибута SUID (set-uid)) вместо x в поле прав на исполнение для владельца
говорит о том, что команда во время выполнения приобретает права
своего владельца, в данном случае root.

Нужно быть аккуратным с `s`, так как при `-rwsrwxrwx`, (`w` для всех) то любой пользователь может
заменить ее собственной программой. Это особенно критично для программ, имеющих атрибут SUID,
так как пользователь root имеет права
на доступ ко всем файлам системы.

Независимо от
имеющихся разрешений, только владелец файла и super-user может изменить права доступа к нему.
Даже если кто-либо предоставит пользователю права на запись в файл, система не позволит ему изменить биты прав доступа

### File access rights

Здесь всё просто

- `r` доступ на чтение
- `w` доступ на запись
- `x` доступ на исполнение

### Directory access rights

Команда ls с параметром -d выводит **сведения о самом каталоге**, а не о
его содержимом, а d в начале строки подтверждает, что «.» действительно является каталогом.

- `r` означает, что каталог доступен для
чтения, и его содержимое может быть просмотрено с помощью команды ls (или, при желании, od). 
- `w` возможно создание и удаление файлов в этом каталоге, поскольку эти действия
требуют записи в файл каталога.

**На самом деле вы не можете записывать данные прямо в файл каталога - это запрещено даже суперпользователю.**

Для этой цели применяются системные вызовы, позволяющие создавать и удалять файлы, - только с их помощью можно
вносить изменения в файл каталога. Но механизм прав доступа работает и здесь: поле
w определяет, кто может использовать системные программы для изменения каталога.

**Разрешение на удаление файла не связано с самим файлом. При наличии права на запись в каталог
можно удалить файлы даже в том случае, если они защищены от записи.**

- `x` разрешает не исполнение, а поиск (переход по иерархии).
Таким образом, можно создать каталог с правами `--x` для остальных пользователей, что позволит им 
получить доступ к тем файлам, которые им известны, но не даст выполнить
команду ls для просмотра всего содержимого каталога.

Аналогично, в каталоге с правами доступа `r--` пользователи могут просматривать его
содержимое, но не могут с ним работать.

В некоторых конфигурациях это свойство используется для отключения каталога /usr/games в рабочее время :)

Обратите внимание на то, что изменение прав доступа к каталогу не затрагивает дату его модификации. 
Дата модификации отражает изменения в содержании каталога, а не в его свойствах. 
Права доступа и даты хранятся не в самом файле, а в индексном дескрипторе (inode)

## inode

Файл имеет несколько компонентов: имя, содержимое, служебную информацию, такую как права доступа и время модификации.
Служебная информация хранится в индексном дескрипторе («inode»).

Индексный дескриптор хранит три значения времени: 
1. время последнего изменения (записи) `ls -l <file>`
2. время последнего использования (чтения или выполнения) `ls -lu <file>`
3. время последнего изменения самого индексного дескриптора, например при изменении прав доступа `ls -lc <file>`

```
touch file_1.txt 
ls -l file_1.txt  # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
ls -lu file_1.txt # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
ls -lc file_1.txt # -rw-r--r-- 1 root root 0 Jan 15 15:19 file_1.txt
```

допишем что-нибудь в файл:

```
echo 123 > file_1.txt 

ls -l file_1.txt  # Jan 15 15:21 <CHANGED>
ls -lu file_1.txt # Jan 15 15:19
ls -lc file_1.txt # Jan 15 15:21 <CHANGED>
```

изменим permissions файла:

```
chmod +x > file_1.txt 

ls -l file_1.txt  # Jan 15 15:21
ls -lu file_1.txt # Jan 15 15:19
ls -lc file_1.txt # Jan 15 17:37 <CHANGED>
```

прочитаем файл:

```
cat file_1.txt 

ls -l file_1.txt  # Jan 15 15:21
ls -lu file_1.txt # Jan 15 17:40 <CHANGED>
ls -lc file_1.txt # Jan 15 17:37
```

Команда `ls -t` сортирует файлы по времени, по умолчанию это время
последнего изменения. Параметр `-t` может применяться совместно с
параметром `-c` или `-u` для определения порядка изменения индексных
дескрипторов или чтения файлов.

Понимание индексных дескрипторов необходимо не только с точки
зрения параметров команды ls, но и потому, что можно сказать, что
inode - это есть файлы.

id inode (i-number) можно получить через `ls -i`

Перед именем файла, в первых двух байтах записи каталога, как раз и
хранится номер inode-ы.
Первые два байта каждой записи каталога являются единственной
связью имени файла с его содержимым. Поэтому имя файла и называется ссылкой, ведь оно связывает 
имя в иерархии каталогов с индексным дескриптором и, следовательно, с данными.

Одно и то же значение номера индексного дескриптора может встречаться в нескольких
каталогах. **Команда rm в действительности удаляет не индексные дескрипторы, а записи в каталоге, то есть ссылки.**
И только когда исчезнет последняя ссылка на файл, система удаляет индексный дескриптор, а значит и сам файл.

Ссылки, указывающие на один файл, имеют одинаковые значения номера индексного дескриптора:

```
ln junk linktojunk
ls 

15768 -rw-rw-rw- 2 you 29 Sep 27 12:07 junk
15768 -rw-rw-rw- 2 you 29 Sep 27 12:07 linktojunk
```

Число между строкой прав доступа и именем владельца показывает
количество ссылок на файл.

Поскольку ссылка есть лишь указатель на
запись в индексном дескрипторе, все ссылки равноправны, нет разницы между первой 
из них и всеми последующими. **(Имейте в виду, что из-за таких повторов ls неправильно подсчитывает итоговый объем
дискового пространства.)**

```
Упражнение 2.6. Почему команда ls -l сообщает о 4 ссылках на recipes? Подсказка: используйте
$ ls 
ld /usr/you
Чем полезна эта информация?
```

```
Упражнение 2.7. В чем разница между
$ mv junk junk1
и
$ cp junk junk1
$ rm junk

Ответ: mv сохраняет inode id
```


## Устройства TODO translate it

`/dev` содержит файлы устройств.

```
ls -l /dev
total 0
crw------- 1 root    root     10, 235 Jan 14 13:02 autofs
drwxr-xr-x 2 root    root          80 Jan 14 13:02 block
drwxr-xr-x 2 root    root          60 Jan 14 13:02 bsg
```

В индексном дескрипторе файла устройства содержится внутреннее имя устройства,
состоящее из обозначения типа символа `c` для символьного или `b` для
блочного, и пара чисел, называемых старшим и младшим номерами
устройства. Диски и ленты являются блочными устройствами, а все остальные - терминалы, принтеры, телефонные линии и 
т. д. - символьными. Старший номер определяет тип устройства, а младший обозначает конкретный экземпляр устройства.

```
crw--w---- 1 root tty     4,  0 Jan 14 13:02 /dev/tty0
crw--w---- 1 root tty     4,  1 Jan 14 13:02 /dev/tty1
crw--w---- 1 root tty     4, 10 Jan 14 13:02 /dev/tty10
```

например здесь мы видим, что для всех терминалов младший номер одинаковый и равен 4.

В процессе начальной загрузки
проверяется целостность всех файловых систем (см. icheck(8) или
fsck(8)), после чего они присоединяются к корневой системе. Операция присоединения 
называется монтированием и представляет собой
программный аналог установки нового диска в дисковод, для ее выполнения необходимы привилегии суперпользователя.

Обычно пользователю нет необходимости задумываться о том, куда
смонтирована каждая из файловых систем, ходя здесь есть два существенных момента. Во-первых,
запрещено создание ссылок на файлы, расположенные в других файловых подсистемах, 
так как они монтируются и размонтируются независимо друг от друга.

Еще одно препятствие состоит в том, что различные файловые системы 
могут содержать совпадающие номера индексных дескрипторов.

Вывод команды можно исключить, перенаправив его в устройство `/dev/null`

Данные, выводимые в /dev/null, пропадают без каких-либо комментариев, 
а при попытке ввода из /dev/null программа немедленно получает признак конца файла, так как операция чтения возвращает ноль
байт.




# Chapter 3 - Shell

Самой важной программой для большинства пользователей UNIX является оболочка - программа,
которая интерпретирует запросы на исполнение команд.

Обычно команда заканчивается символом разделителя строк, но часто
для завершения команды применяется и точка с запятой ;

```
[root@linux01z1 test] date; who
Sun Jan 15 20:29:04 CET 2017
vagrant  pts/0        2017-01-15 20:28 (gateway)
```

В частности, who не выполняется до тех пор, пока не завершится date.

Попытаемся передать вывод «date; who» в канал:

```
$ date; who | wc
Wed Sep 28 09:08:48 EDT 1983
2  10  60
$
```

Вероятно, это не совсем то, чего вы ожидали. Дело в том, что только вывод 
who передается wc. Соединение команд who и wc посредством канала
образует единую команду, которая называется конвейером (pipeline),
она-то и выполняется после завершения date. При разборе командной
строки оболочка учитывает то, что приоритет `|` выше, чем приоритет `;`.

Можно сгруппировать команды при помощи скобок:

> $ (date; who) | wc

**Поток данных по каналу может быть перехвачен и помещен в файл (но
не в другой канал) с помощью команды `tee`**, которая не входит в оболоч
ку, но может быть полезна для работы с каналами.

Одно из ее возможных применений - это сохранение промежуточного вывода в файле:

```
$ (date; who) | tee save | wc
3  16  89
$ cat save
Wed Sep 28 09:13:22 EDT 1983
you  tty2  Sep 28 07:51
jpl  tty4  Sep 28 08:32
$ wc <save
3  16  89
```

Команда tee копирует свой ввод в указанный файл или файлы, а также
в свой вывод, так что wc получает те же входные данные, которые бы
она получила, если бы `tee` не входила в конвейер.


Различные специальные символы, интерпретируемые оболочкой (такие, как <, >, |, ; и &), 
не являются аргументами запускаемых программ.

Вместо этого они контролируют то, как оболочка их запускает.
Например,

> $ echo Hello >junk

Здесь сообщается, что оболочка должна запустить echo с единственным
аргументом Hello и поместить вывод в файл junk. Строка >junk не является аргументом команды echo; 
она интерпретируется оболочкой, и echo ее даже не видит. На самом деле эта строка не обязательно должна
быть последней в команде:

> $ >junk echo Hello

В этом случае происходит то же самое, но такая запись менее очевидна.

С годами оператор перенаправления < уступил в популярности каналам, 
похоже, конструкция `cat file |` кажется людям более естественной, чем `<file`.


## Метасимволы

Оболочка распознает и ряд других символов как специальные; чаще
всего встречается звездочка *, сообщающая оболочке, что следует просмотреть 
каталог в поиске файлов с именами, в которых на месте * стоит любая символьная строка. Например,

> $ echo *

это подобие `ls`.

При проверке имен файлов на совпадение не рассматриваются имена, начинающиеся
с точки, чтобы избежать проблем с именами «.» и «..», которые есть в
каждом каталоге.

```
$ ls
.profile
junk
temp

$ echo *
junk temp

$ echo .*
. .. .profile
```

Такие символы, как *, имеющие специальные свойства, называются метасимволами.

Самый простой и хороший способ защитить специальные символы от интерпретации оболочкой состоит в том, чтобы
заключить их в одинарные кавычки:

```
$ echo '***'
***
```

Или ввести обратную косую черту \ перед каждым символом, который требуется защитить от обработки оболочкой.

Метасимволы оболочки:
- `>`
- `>>`
- `<`
- `|`
- `<<str`   # here document
- `*`      # любая строка
- `?`       # любой символ
- `[ccc]` # любому отдельному символу из ccc
- `;`
- `&`
- \`...\` # выполнение команды
- `(...)` # выполняет команду в дочерней оболочке
- `{...}` # выполняет команду в текущей оболочке (редко используется)
- `$1, $2` и т. д. # $0...$9 заменяются аргументами, переданными командному файлу
- `$var`
- `${var}` # значение var, предотвращает перемешивание при объединении с текстом
- \# коммент
- `p1 && p2` # запускает p1 и в случае успеха запускает p2
- `p1 || p2` # запускает p1 и в случае неудачи запускает p2


Обратная косая черта в конце строки означает, что строка будет продолжена; таким образом можно передать оболочке очень длинную строку.

```
$ echo abc\
> def\
> ghi
abcdefghi
$
```

```
Упражнение 3.2. Объясните, каким будет вывод
$ ls .*
```


## echo

Команда echo выводит заключительный символ разделителя строк, хотя 
в явном виде такое требование не существует. Конструкция команды была бы более разумной и «чистой», если бы echo выводила только
то, что требуется. Тогда было бы проще выдавать приглашения на ввод.

Но в таком варианте есть и недостаток - очень часто оказывается, что
переход на новую строку после завершения команды желателен, а его
отсутствие вызывает необходимость дополнительного ввода.

параметр `-n` убирает последний разделитель строк.

```
Упражнение 3.6 (сложный вопрос). Каким образом ввести / в имя файла 
(так, чтобы этот символ не воспринимался как разделяющий компоненты имени)?
```


## arguments 

> $1..$9 заменяет входные аргументы

Работает только для 9 аргументов, потому что строка $10 воспринимается как «первый аргумент, $1, за которым следует 0»!

`$*` означает «все аргументы».

Аргумент `$0` является именем исполняемой программы.

```
[root@linux01z1 tmp] cat test/1.sh 
echo $0

[root@linux01z1 tmp] ./test/1.sh 
./test/1.sh

[root@linux01z1 test] ./1.sh 
./1.sh
```

## variables

`set` показывает значения всех определенных переменных.

```
TESTVAR=1

set | grep TEST
>> TESTVAR=1
```

Значение переменной сопоставлено оболочке, которая создала ее, и не
передается автоматически потомку оболочки.

**Командный файл не может изменить значение переменной, потому
что он запускается подоболочкой**.
Именно поэтому если нужно переопределить обычные переменные или переменные окружения, то использую `source` или `.`

Исполнение файла командой . только внешне напоминает запуск командного файла.
В обычном смысле слова файл не «исполняется».
Вместо этого команды файла интерпретируются точно таким образом,
как если бы они вводились интерактивно - стандартный ввод оболочки
временно перенаправлен и поступает из файла.
**Так как файл не исполняется, а только читается, ему не нужны права на исполнение.**

Значение переменной можно сделать доступным в подоболочках с по
мощью команды оболочки `export`.


## Advanced input-output

Стандартный вывод ошибок организован так, чтобы сообщения о них
всегда появлялись на терминале:

```
$ diff file1 fiel2 >diff.out
diff: fiel2: No such file or directory
```

И в самом деле желательно, чтобы сообщения об ошибках обрабатывались именно так, 
ведь вряд ли можно назвать удачным способ, при котором сообщения исчезали бы в файле diff.out, оставляя пользователя
в полной уверенности, что команда отработала правильно.

При запуске любой программы по умолчанию порождаются три файла,
пронумерованные небольшими целыми числами, которые называются
дескрипторами файла:
- 0 Стандартный ввод
- 1 стандартный вывод
- 2 стандартный вывод ошибок, который обычно попадает на терминал.

Иногда программы производят вывод в файл стандартного вывода
ошибок, даже если работают правильно. Так поступает программа `time`

```
[root@linux01z1 test] time > time.txt

real	0m0.000s
user	0m0.000s
sys	0m0.000s
[root@linux01z1 test] cat time.txt 
[root@linux01z1 test] 
```

Конструкция `2>имя-файла` (пробелы между 2 и знаком > недопустимы)
направляет стандартный вывод ошибок в файл.

Также существует возможность объединения двух выходных потоков:
Запись `2>&1` говорит оболочке, что следует поместить вывод стандартных ошибок в тот же поток.

```
[root@linux01z1 test] cat <<End
dialajoke 2129763838
dialaprayer 2122464200
dial santa 2129763636
dow jones report 2129764141
End

# dialajoke 2129763838
# dialaprayer 2122464200
# dial santa 2129763636
# dow jones report 2129764141
```

такая конструкция называется встроенным документом (`here document`); это означает, 
что входные данные находятся там же, где и сама команда, а не в каком-то отдельном файле. 
Символ << обозначает эту конструкцию; слово, следующее за ним (в данном примере - End), 
служит для того, чтобы ограничить ввод, который
понимается как все, что предшествует такому слову, находящемуся в
отдельной строке. Оболочка заменяет символы $, `...` и \ во входных
данных встроенного документа, если только какаято часть слова не
заключена в кавычки или не использована обратная косая черта; в
этом случае весь документ воспринимается буквально.

Таблица 3.2. Перенаправление ввода5вывода в оболочке:

- `>file` направляет стандартный вывод в file
- `>>file` добавляет стандартный вывод в file
- `<file` получает стандартный ввод из file
- `p1 |p2` соединяет стандартный вывод программы p1 со вводом p2
- `n>file` прямой вывод из файлового дескриптора n в file
- `n>>file` добавляет вывод из файлового дескриптора n в file
- `n>&m` объединяет вывод из файлового дескриптора n с файловым дескриптором m
- `n<&m` объединяет ввод из файлового дескриптора n с файловым дескриптором m
- `<<s` встроенный документ: получает стандартный ввод до тех пор, пока в начале строки не встретится s
- `<<\s` встроенный документ без подстановок
- `<<'s'` встроенный документ без подстановок

```
MYVAR=777

cat<<End
here doc $MYVAR
End

# >> here doc 777


cat<<'End'
here doc $MYVAR
End

# >> here doc $MYVAR
```

## Loops

Синтаксис for:

```
for i in *
do
  echo $i
done
```

В зависимости от размеров for, иногда бывает удобнее записать все в одной строке:

> for i in список; do команды; done

do и done воспринимаются как зарезервированные слова,
только если они появляются после символа новой строки или точки с запятой.

Но не применяйте его для одной команды, которая будет перебирать
имена файлов:

Плохая идея:
```
for i in $*
do
  chmod +x $i
done
```

хуже, чем
```
chmod +x $*
```

потому что цикл for выполняет отдельную команду chmod для каждого
файла, что требует значительно бoльших компьютерных ресурсов.

Убедитесь, что вы понимаете различие между

> for i in *

где перебираются все файлы в текущем каталоге, и

> for i in $*

где перебираются все аргументы командного файла.



# Chapter 4 - Filters

Существует большое семейство программ для UNIX, вводящих некоторые данные, 
выполняющих простые преобразования и что-либо выводящих. Примером могут служить grep и tail для выбора данных из
входного потока, sort для их сортировки, wc для подсчета, sed (stream editor - потоковый редактор) и awk, 
названная в честь своих авторов. и т. д. Такие программы называются фильтрами.

> $ grep шаблон имена-файлов

```
grep From $MAIL | grep -v mary
# Заголовки сообщений, не принадлежащих mary
```

Таблица Регулярные выражения grep и egrep (в порядке понижения приоритета)

| Метасимволы | Значение | 
|:--------|:-------:|
| `c`       | любой не специальный символ c совпадает сам с собой   |
| `\c`      | отключает все специальные значения символа c   |
| `^`       | начало строки   |
| `$`       | конец строки   |
| `.`       | произвольный одиночный символ   |
| `[...]`   | любой из символов множества ...; допустимы диапазоны, например a-z   |
| `[^...]`  | любой символ, не входящий в ...; допустимы диапазоны   |
| `\n`      | то же, что в n-м фрагменте \(...\) (только grep)  |
| `r*`      | ноль или больше вхождений r   |
| `r+`      | одно или больше вхождений r (только egrep)   |
| `r?`      | ноль или одно вхождение r (только egrep)   |
| `r1r2`    | r2 следует за r1   |
| `r1|r2`   | r1 или r2 (только egrep)  |
| `\(r\)`   | регулярное выражение r с тегами (только grep); может быть вложенным   |
| `(r)`     | регулярное выражение r (только egrep); может быть вложенным   |

> $ grep '^From' $MAIL

`*` соответствует строке любых символов, а
`.*x` - строке произвольных символов, заканчивающейся символом x

Программа grep - старейший член семейства, в котором позже появились fgrep и egrep. 
Сущность их работы одинакова, за исключением того, что fgrep выполняет поиск одновременно нескольких строк, a egrep
интерпретирует истинные регулярные выражения так же, как grep, но
с использованием оператора ИЛИ и скобок, позволяющих группировать выражения, как это описано ниже.

Обе команды позволяют при помощи параметра -f указать файл, содержащий шаблон.

Команда egrep обрабатывает те же регулярные выражения, что и grep
, но с несколькими дополнениями. Скобки позволяют
группировать выражения, так что (xy)* определяет пустую строку, xy,
xyxy, xyxyxy и т. д. Оператор или записывается как вертикальная черта
|; выражение today|tomorrow означает today либо tomorrow - так же, как
и выражение to(day|morrow). И наконец, в egrep имеются два дополнительных 
оператора замыкания, + и ?. Шаблон x+ определяет один или
больше символов x, а x? - ноль или один символ, но не больше.


## sed

`sed` читает построчно входной файл; выполняет поочередно команды из
списка над каждой строкой и выводит результат на стандартное устройство вывода.

Так, можно заменить все вхождения `UNIX` на `UNIX(TM)` в
группе файлов командой

> $ sed 's/UNIX/UNIX(TM)/g' имена-файлов ... >output

Не ошибитесь в том, что здесь происходит: sed не изменяет содержимого 
входных файлов, а использует стандартный вывод, оставляя исходные файлы нетронутыми.

можно получить имена пользователей и время
регистрации из данных, выводимых командой who:

```
[root@linux01z1 test] who
vagrant  pts/0        2017-01-15 20:28 (gateway)

[root@linux01z1 test] who | sed 's/ .* / /'
vagrant (gateway)
```

Команда s выполняет замену пробела и всего, что за ним следует,
включая следующий пробел, единственным пробелом.

Можно также поместить команды sed в файл и вызывать их оттуда
строкой

> $ sed -f cmdfile ...

Автоматический вывод результатов, вполне пригодный в большинстве
случаев, иногда бывает нежелателен. Он может быть выключен параметром `–n`; 
в этом случае выводятся только строки, явно отправленные
на печать командой p. Например,

> $ sed –n '/шаблон/p'

делает то же самое, что и grep. А поскольку условие совпадения может
быть инвертировано, то команда

> $ sed –n '/шаблон/!p'

эквивалентна grep –v.

Зачем использовать обе команды – sed и grep? В конце концов, grep -
всего лишь простой частный случай sed. Частично это объясняется 
историческими причинами – команда grep появилась намного раньше,
чем sed. Но grep живет и процветает благодаря своей лаконичности: с
ее помощью проще выполнить ту работу, которую обе команды выполняют одинаково.

p.s. На самом деле проще использовать только `grep` и `awk` и забыть про sed :)


## awk

**Некоторые ограничения sed устранены в программе awk**. В ее основу по
ложена та же идея, что и в sed, но реализация ближе к языку Си, чем к
текстовому редактору.

Формат вызова программы аналогичен sed:

> $ awk 'program' имена-файлов ...

но аргумент program имеет другое значение:

```
шаблон { действие }
шаблон { действие }
...
```

Программа awk читает входные файлы имена5файлов построчно. 
Каждая строка проверяется на соответствие с каждым шаблоном; при наличии соответствия выполняются действия. 
Как и sed, программа awk не изменяет входные файлы.

**В качестве шаблонов могут выступать регулярные выражения, те же,
что и в egrep**, или более сложные условные выражения, напоминающие язык Си.

Вот простой пример:

> $ awk '/регулярное выражение/ { print }' имена-файлов ...

работает аналогично программе egrep: выводит все строки, определяемые регулярным выражением.

```
[root@linux01z1 test] cat 1.txt 
555
567
333
5556

[root@linux01z1 test] awk '/.*/ {print}' 1.txt 
555
567
333
5556

[root@linux01z1 test] awk '/55.*/ {print}' 1.txt 
555
5556
```

Необязательно одновременно указывать и шаблон, и действие. Если
отсутствует действие, то выполняется действие по умолчанию - вывод
выбранных шаблоном строк.

> $ awk '/регулярное выражение /' имена-файлов ...

выполняется аналогично предыдущей. Если же не задан шаблон, то
действие выполняется над каждой входной строкой, и команда

> $ awk '{ print }' имена-файлов ...

```
[root@linux01z1 test] ls | awk '{print}'
1.sh
1.txt

[root@linux01z1 test] ls | cat
1.sh
1.txt
```

**делает то же, что и cat, только намного медленнее.**

Команде awk, как и sed, можно передать файл с программой:

> $ awk -f cmdfile имена-файлов ...


### awk - collumns

Программа awk автоматически делит каждую прочитанную строку на
поля – строки символов (не пробелов), разделенные пробелами или
знаками табуляции. Согласно этому определению строки, выводимые
командой who, содержат пять полей:

```
[root@linux01z1 test] who
vagrant  pts/0        2017-01-15 20:28 (gateway)
```

Этим полям awk присваивает имена $1, $2, ..., $NF, где NF – переменная, содержащая количество полей в строке.

```
[root@linux01z1 test] who | awk '{print $1}'
vagrant

[root@linux01z1 test] who | awk '{print $1, $2}'
vagrant pts/0

```

(Обратите внимание на то, что NF – это количество полей, а $NF – последнее поле в строке. В отличие от оболочки,
переменные awk не имеют префикса $, за исключением имен полей.)

```
[root@linux01z1 test] who | awk '{print NF}'
5

[root@linux01z1 test] who | awk '{print $NF}'
(gateway)
```

По умолчанию awk считает, что поля разделены пробелами и знаками
табуляции, но позволяет определить в качестве разделителя любой
символ. Это можно сделать с помощью параметра –F (верхний регистр).


### awk - printing

Кроме подсчета полей на входе awk ведет и другую интересную статистику. 
Встроенная переменная `NR` хранит порядковый номер текущей
входной строки. Для вывода номеров строк используйте команду

```
[root@linux01z1 test] ls -l | awk '{ print NR, $0 }'
1 total 12
2 -rwxr-xr-x 1 root root  8 Jan 16 22:33 1.sh
3 -rw-r--r-- 1 root root 17 Jan 17 22:08 1.txt
4 -rwxr-xr-x 1 root root  4 Jan 15 15:21 file_1.txt
5 -rw-r--r-- 1 root root  0 Jan 16 23:00 time.out
6 -rw-r--r-- 1 root root  0 Jan 16 22:56 time.txt
7 -rw-r--r-- 1 root root  0 Jan 16 22:59 wc.out
```

Поле $0 представляет собой всю входную строку целиком. В операторе
print значения, разделяемые запятыми, печатаются через разделитель
выходных полей, по умолчанию это пробел.

Если возможностей форматирования оператора print недостаточно, то
можно обратиться к `printf`. Так, например, можно напечатать номера
строк в поле длиной четыре символа:

```
[root@linux01z1 test] ls | awk '{ printf "%4d %s\n", NR, $0 }'
   1 1.sh
   2 1.txt
   3 file_1.txt
   4 time.out
   5 time.txt
   6 wc.out
```

Здесь спецификатор формата %4d задает отображение десятичного 
целого (NR) в четырехсимвольном поле, а спецификатор %s – отображение 
строки символов ($0), добавлен также символ новой строки \n, поскольку 
printf самостоятельно его не добавляет. **Оператор printf программы awk аналогичен функции языка Си**


### awk - templates

```
[root@linux01z1 test] ls  -l | awk '$9 == "1.txt"'
-rw-r--r-- 1 root root 17 Jan 17 22:08 1.txt
```

Можно эту условие (шаблон) написать и другими способами.

```
[root@linux01z1 test] ls  -l | awk '$9 ~ /^1.txt$/'
-rw-r--r-- 1 root root 17 Jan 17 22:08 1.txt
```

Символ `~` означает соответствие регулярному выражению, а `!~` - отсутствие соответствия.

Символ `!` в начале шаблона означает отрицание, например

> !($2 == "")

Оператор ! подобен оператору языка Си.

В программе awk действует то же соглашение о комментариях, что и в
оболочке: **комментарий начинается с символа #**.

В awk существуют два специальных шаблона, `BEGIN` и `END`. 

BEGIN позволяет определить действия, выполняемые до того, как будет прочитана
первая строка ввода; этот шаблон можно использовать для инициализации переменных, 
печати заголовков или для переопределения разделителя полей присваиванием значения переменной FS:

Шаблон END определяет действия, выполняемые после того, как будет обработана последняя строка.


### awk - operations

До сих пор рассматривались только примеры несложного преобразования строк. 
Настоящая же мощь awk заключается в способности выполнять вычисления на основе входных данных – подсчитывать объекты,
вычислять суммы и средние значения и т. п.

Часто awk применяется
для суммирования столбцов чисел. Так, например, выполняется сложение всех чисел из конкретного столбца:

```
notier [root@linux1 vagrant]# ls -l
total 12
-rw-r--r-- 1 root root  1 Jan 23 23:50 1.txt
-rw-r--r-- 1 root root 18 Jan 25 18:35 2.txt
-rw-r--r-- 1 root root  9 Jan 25 18:36 3.txt

notier [root@linux1 vagrant]# ls -l | awk '{ s = s + $5 } END { print s }'
28 # кол-во байт всего в файлах

```

Этот пример демонстрирует также работу с переменными в awk. 
Переменная s не является встроенной, она определена в момент первого исользования. 
По умолчанию переменные инициализируются нулем, поэтому явная инициализация обычно не требуется.


**Условный оператор if** имеет тот же вид, что и в языке Си.

```
if (условие)
  оператор1
else
  оператор2
```

For

```
for (выражение1; условие; выражение2)
  оператор
  
# for (i = 2; i <= NF; i++)
```

Оператор break вызывает передачу управления за пределы ближайшего 
цикла while или for; оператор continue вызывает переход к следующей 
итерации (в точку условие в цикле while и в точку выражение2 в
цикле for). Оператор next инициирует ввод следующей строки и переход к 
первому шаблону программы для ее обработки. Оператор exit
немедленно передает управление шаблону END.

Как и большинство языков программирования, awk имеет средства работы с массивами и ассоциативными массивами.

**Короче, в awk можно сделать практически те же вычисления, что и в языке C 
(но нужно ли вам это??? Возможно проще написать скрипт на Python для этой задачи)!**



# shell programming

оператор case:

```
case слово in
шаблон)  команды ;;
шаблон)  команды ;;
...
esac
```

Оператор case сравнивает слово с шаблонами, двигаясь сверху вниз, и
выполняет команды, соответствующие первому (и только первому)
подходящему шаблону.

Каждое действие завершается двойной точкой с запятой ;;. 
(Последняя пара ;; не обязательна, но оставим ее для удобства редактирования.)


Таблица Встроенные переменные оболочки

| Переменная | Смысл | 
|:--------|:-------:|
| `$#`      | количество аргументов   |
| `$*`      | все аргументы |
| `$@`      | аналогично $*  |
| `$-`      | параметры, переданные оболочке  |
| `$?`      | возвращает код завершения последней выполненной команды |
| `$$`      | идентификатор процесса оболочки |
| `$!`      | идентификатор процесса для последней команды, запущенной с & |
| `$HOME`   | аргумент по умолчанию для команды cd |
| `$IFS`    | список символов, которые разделяют слова в аргументах |
| `$MAIL`   | файл, при изменении которого выводится сообщение «you have mail» |
| `$PATH`   | список каталогов для поиска команд |
| `$PS1`    | строка приглашения на ввод, по умолчанию `$` |
| `$PS2`    | строка приглашения на продолжение командной строки, по умолчанию `>` |

example:

```
notier [root@linux1 vagrant]# cat 1.sh 
echo "arguments number: $#"

case $# in
0)   echo 'test'; echo '-0-';;
1)   echo 'test'; echo '-1-';;
esac
```

```
notier [root@linux1 vagrant]# ./1.sh 
arguments number: 0
test
-0-

notier [root@linux1 vagrant]# ./1.sh 1
arguments number: 1
test
-1-

notier [root@linux1 vagrant]# ./1.sh 1 2
arguments number: 2

```


```
notier [root@linux1 vagrant]# date
Wed Jan 25 19:26:20 CET 2017
notier [root@linux1 vagrant]# set `date`
notier [root@linux1 vagrant]# echo $1
Wed
notier [root@linux1 vagrant]# echo $2
Jan


notier [root@linux1 vagrant]# set aaa bbb ccc
notier [root@linux1 vagrant]# echo $1
aaa
notier [root@linux1 vagrant]# echo $2
bbb

```

Команда set при отсутствии аргументов она отображает
значения переменных окружения.
Одиночные аргументы устанавливают значения переменных $1, $2 и т. д.

Команда set также распознает различные параметры, самыми распространенными 
из них являются `-v` и `-x`; они включают режим отображения 
на терминале команд по мере их обработки оболочкой. Эти параметры необходимы для отладки сложных программ.

Таблица Шаблоны оболочки

- `*` соответствует любой строке, в том числе и пустой
- `?` соответствует любому отдельному символу
- `[ccc]` соответствует любому из символов в ccc `[a-d0-3]` эквивалентно `[abcd0123]`
- `"..."` точно соответствует ...
- `\c` буквально соответствует с
- `a|b` (только для операторов case) соответствует или a, или b
- `/` для имен файлов соответствует только явному знаку / в выражении; для оператора case обрабатывается подобно обычным символам
- `.` будучи первым символом имени файла, соответствует только явной `.` в выражении

p 171


